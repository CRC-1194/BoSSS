\section{Two-dimensional heat equation}
\label{sec:heat2d}
This chapter deals with the solution of the two-dimensional heat equation
\begin{equation}
  \frac{\partial u}{\partial t} - \kappa \left(
    \frac{\partial^2 u}{\partial x_1^2}
    + \frac{\partial^2 u}{\partial x_2^2}
  \right)
  ~~~ x = \binom{x_1}{x_2} \in \Omega = [0; 2\pi] \times [0; 2\pi]
\label{eq:heat}
\end{equation}
with the boundary conditions
\begin{equation}
  u_{\partial \Omega} = 0
\label{eq:heat_boundary}
\end{equation}
and the initial condition
\begin{equation}
  u_0 = sin(x_1) sin(x_2).
\label{eq:heat_initial}
\end{equation}

Using the framework described in section \ref{sec:theoreticalBackground}, this
setting can be expressed via
\begin{align}
  d &= 2\\
  \hat{f} &= -c_0 [u]\\
  b_{ij} &= \delta_{ij} \sqrt{\kappa}\\
  g_{ij} &= \delta_{ij} \sqrt{\kappa} u\\
  q_k &= \sqrt{\kappa} \frac{\partial u}{\partial x_k}\\
  Q &= 0
\end{align}
which leads to the formulation
\begin{align}
\label{eq:heat_u_equation}
	\int_K {\frac{\partial u^h}{\partial t} \varphi_u dx}
	- \int_K {
		-\sqrt{\kappa} q_1^h \frac{\partial \varphi_u}{\partial x_1}
		-\sqrt{\kappa} q_2^h \frac{\partial \varphi_u}{\partial x_2}
	dx}
	+ \int_{\partial K} {h_u(u^h, q^h, n, x, t) \varphi_u dS}
	&= 0\\
\label{eq:heat_q_equation}
	- \int_K {\sqrt{\kappa} u \frac{\partial \varphi_{q_k}}{\partial x_k} dx}
	+ \int_{\partial K} {h_{q_k}(u^h, q^h, n, x, t) \varphi_q dS}
	&= \int_K {q_k^h \varphi_{q_k} dx}
\end{align}
\begin{align}
\label{eq:heat_u_flux}
  h_u(u^h, q^h, n, x, t)
	&= -c_0 [u]
	- \sqrt{\kappa} (\{q_1\} n_1 + \{q_2\} n_2)
	- c_1 ([q_1] + [q_2])\\
\label{eq:heat_q_flux}
  h_{q_k}(u^h, q^h, n, x, t)
  &= \{u\} n_k
  - c_k[u]
\end{align}
where we have assumed $c_1=c_2$ for simplicity. This expression is equivalent
to the system
\begin{align}
\label{eq:heat_u_equation2}
	\int_K {\frac{\partial u^h}{\partial t} \varphi_u dx}
	- \int_K {
		-\kappa \tilde{q}_1^h \frac{\partial \varphi_u}{\partial x_1}
		-\kappa \tilde{q}_2^h \frac{\partial \varphi_u}{\partial x_2}
	dx}
	+ \int_{\partial K} {h_u(u^h, \tilde{q}^h, n, x, t) \varphi_u dS}
	&= 0\\
\label{eq:heat_q_equation2}
	- \int_K {u \frac{\partial \varphi_{q_k}}{\partial x_k} dx}
	+ \int_{\partial K} {h_{q_k}(u^h, \tilde{q}^h, n, x, t) \varphi_q dS}
	&= \int_K {\tilde{q}_k^h \varphi_{q_k} dx}
\end{align}
\begin{align}
\label{eq:heat_u_flux2}
  h_u(u^h, \tilde{q}^h, n, x, t)
	&= -c_0 [u]
	- \kappa (\{\tilde{q}_1\} n_1 + \{\tilde{q}_2\} n_2)
	- c_1 \sqrt{\kappa} ([\tilde{q}_1] + [\tilde{q}_2])\\
\label{eq:heat_q_flux2}
  h_{q_k}(u^h, \tilde{q}^h, n, x, t)
  &= \{u\} n_k
  - c_k[u]
\end{align}
where $q_k = \sqrt{\kappa} \tilde{q_k}$.

The full BoSSS implementation of the system
\ref{eq:heat_u_equation2}-\ref{eq:heat_q_flux2} is located in the 
sub-directory\linebreak \verb|src\public\L4-application\LDGHeat\| of any BoSSS developer 
installation. The listings provided in this section only highlight the most 
important differences compared to the treatment of a one-dimensional equation 
(like the Poisson equation discussed in section \ref{sec:poission1d}) in BoSSS.

\begin{lstlisting}[caption=BoSSS implementation of equations 
\ref{eq:heat_u_equation2} and \ref{eq:heat_u_flux2}, label=lst:heat_flux_u]
class uFlux : LinearFlux {
    
  [...]
    
  protected override double BorderEdgeFlux(ref InParams inp, double[] Uin) {
    return InnerEdgeFlux(ref inp, Uin, new double[] { 0.0, Uin[1], Uin[2] });
  }
  
  protected override void Flux(double[] x, double[] parameters, double[] U, double[] output) {
    output[0] = -m_kappa * U[1];
    output[1] = -m_kappa * U[2];
  }
  
  public override IList<string> ArgumentOrdering {
    get { return new string[] { "u", "q1", "q2" }; }
  }
}
\end{lstlisting}

Listing \ref{lst:heat_flux_u} shows the implementation of flux function for the
original variable $u$. Here, unlike the one-dimensional case, the \emph{Flux} 
function has to treat different fluxes associated with different spatial 
derivatives of the test function (cf. the second integral in equation
\ref{eq:heat_u_equation2}). That is why the array \emph{output} always has $d$ 
dimensions where \emph{output[i]} should represent the flux associated with the
spatial derivative of the test function in $x_i$ direction.

\begin{lstlisting}[caption=Assembly of the DG operator for the heat equation, 
label=lst:heat_operator]
class Program : BoSSS.Solution.Application {

  [...]
  
  protected override void CreateEquationsAndSolvers() {
    double c0 = 100.0;
    double c1 = 1.0;
    double kappa = 10.0;

    SpatialDifferentialOperator operator = new SpatialDifferentialOperator(
                3, 3, "u", "du/dx", "du/dy", "_1", "_2", "_3");
            operator.EquationComponents["_1"].Add(new Fluxes.uFlux(kappa, C0, C1));
            operator.EquationComponents["_2"].Add(new Fluxes.qFlux(C1, 0));
            operator.EquationComponents["_2"].Add(new Fluxes.LDGSource(0));
            operator.EquationComponents["_3"].Add(new Fluxes.qFlux(C1, 1));
            operator.EquationComponents["_3"].Add(new Fluxes.LDGSource(1));
            operator.Commit();

    [...]
  }
}
\end{lstlisting}

\begin{lstlisting}[caption=BoSSS implementation of the right hand side of
equation \ref{eq:heat_q_equation2}, label=lst:heat_source_q]
class uSource : LinearSource {
  
  [...]
  
  private string[] m_ArgumentMapping;
  
  public LDGSource(int d) {
    if (d == 0) {
      m_ArgumentMapping = new string[] { "du/dx" };
    } else if (d == 1) {
      m_ArgumentMapping = new string[] { "du/dy" };
    } else {
      throw new ArgumentException("Dimension must be 0 or 1");
    }
  }
  
  protected override double Source(double[] x, double[] parameters, double[] U) {
    return -U[0];
  }
  
  public override IList<string> ArgumentOrdering {
    get { return m_ArgumentMapping; }
  }
}
\end{lstlisting}

Having implemented the numerical fluxes, the 
\emph{SpatialDifferentialOperator} has to be assembled. This procedure is 
depicted in listing \ref{lst:heat_operator} where one can see that our operator
now consists of three equations (components \emph{\_1}, \emph{\_2} and 
\emph{\_3}) instead of two. Additionally, the constructors of the \emph{qFlux} 
and the \emph{LDGSource} consume an argument which indicates the direction of 
the associated derivative. An example for the usage of this parameter can be 
seen in listing \ref{lst:heat_source_q} the constructor uses the argument $d$
in order to determine if the derivative in $x_1$- ("`du/dx"') or 
$x_2$-direction ("`du/dy"') is required as a source term.
