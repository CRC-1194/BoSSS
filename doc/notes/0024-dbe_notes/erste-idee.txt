

1. the API, basics
==================

The object that we want to handle in the database are,
for instance, Sessions or Grids.
At first, we define some "information objects" for all of these:
E.g. for each "Grid"-object, which are 'heavy weight', since each of them is maybe severeal megabytes 
in size, we define the "GridInfo"-object:

   // Common for all Database objects
   interface IDatabaseObjectInfo : ISerializeable, IDisposable {
       Guid { get };
       DateTime Creationtime { get };
       string Name { get };
       Update();
       IDatabaseInfo DB;
   }

   interface IDatabaseInfo {
       string Path;
   }

   interface ISessionInfo : IDatabaseObjectInfo {
       string ProjectName { get; }
       IEnumerable<ITimestepInfo> Timesteps { get; }
       
	   // this session has been restarted from ...
	   ISessionInfo RestartedFrom { get; }
	   
	   // tags set for the session
	   IEnumerable<string> Tags { get; }
	   ...
	   
	   // loads/returns all queries 
	   GetQueries();
   }

   interface IGridInfo : IDatabaseObjectInfo {
       int NoOfCells { get; }
   }

   // the "Project" is some kind of an "implicit object", i.e.
   // it has no real counterpart on the harddisk, like e.g. a session;
   // Instead, projects are generated by collecting all <see "ISessionInfo.ProjectName"/>-strings
   // from all session objects.
   interface IProjectInfo : IDatabaseObjectInfo {
       IEnumerable<ISessionInfo> Sessions { get };
       IEnumerable<IGridInfo> Grids { get };
	   IEnumerable<string> TagsInProject { get; }
	   
	   // for the definition of IChainInfo, see below
	   IEnumerable<IChainInfo> Chains { get }
   }

   interface ITimestepInfo {
       // the timestep index/number; in order to handle inner iterations,
       // and possibly inner iterations of inner interations, and so on,
       // this is defines as an array
       int[] index;
	
       // names of variables (e.g. 'VelocityX', ...)
       // which are stored in this timestep
       IEnumerable<string> Variables;
	   
	   IGridInfo Grid;
   }

Finally, all these objects should be presented via a "Database" - object;

   class Database {
       static Database Open(string path);
       static Database Open(IDatabaseInfo info);
	
       IEnumerable<ISessionInfo> AllSessions { get };
       IEnumerable<IGridInfo> AllGrids { get };
       IEnumerable<IprojectInfo> Projects { get }
	   
	   // the following functions really 'load/save' the objecs which are desdribed by
	   // the info-objects.
	   GridCommons LoadGrid(IGridInfo info);
	   IGridInfo SaveGrid(GridCommons g);
	   Field[] LoadTimestep(ITimestepInfo info);                 // loads fields and grid
	   Field[] LoadTimestep(ITimestepInfo info, Grid g);         // loads fields 'into' an already present grid
	   void LoadTimestep(ITimestepInfo info, Grid g, Field[] f); // loads into already allocated fields
	   ...
   }

Summary
-------

For each database, we offer a tree like the following one:

Database
  AllGrids
     A
	 B
	 C
  AllSessions
     1, 2, 3, 4, 5, 6, 7, 8, 9
  Projects
     Ex-Prj-1
	   Sessions
	     2, 3, 4, 5
	   Grids
	     A, C
	 Ex-Prj-2
	   Sessions
	     1, 6, 7, 8, 9
	   Grids
	     B, C

A tree like this may be shown in the GUI-version of the DBE;


2. Interacting via C# - shell (REPL)
====================================

2.1 Browsing, Plotting
----------------------

The C#-REPL, in conjunction with LINQ, offers an easy and intuitive way to browse the database;
On startup, we assume that all databases listed in a configuration file 
(like ~/.boSSS/etc/DBE.xml) are opened by some kind of init script.

Someone may browse the database like this:

   csharp> var prj = DB1.Projects.Where(p => p.Name.StartsWith("wall-mounted-cu")).First();
   wall-mounted-cube     Sessions: 8

Of course, certain queries that are used very often may be abbreviated with 
specific extension functions. The query form above (getting the "wall-mounted-cube" - project)
is such an example.
Once he got his project, he may continue like that:

   csharp> var sess = prj.Sessions.SortByDate().Last();
   3EE787C4-6BD3-4D2C-BFDC-361063F2E0AD     Date: 7/5/2013 8:10:35 AM
   csharp>
   csharp> sess.Timesteps.SelectEvery(5).Plot(supersampling:3);
   
Here, we assume three extension functions: 
 - SortByDate() (on IEnumerable<IDatabaseObjectInfo>)
 - SelectEvery(int) on IEnumerable<ITimestepInfo>
 - Plot(...) on ITimestepInfo
The first two ones are self-explaining; the Plot(...)-function is a bit more interesting:
Basically, it should start the PlotGenerator.exe in an external process.
Since all IDatabaseObjectInfo - Objects are serializeable, it is quite easy to pass them 
to external processes. the procedure could look approximately like this:
  1. Plot(...) saves input object for the plot generator: of ITimestepInfo
  2. Plot(...) forks PlotGenerator.exe in an external process.
  3. Form its input-object, the plot generator, can determine 
     - which database he has to open (<see IDatabaseObjectInfo.DB/>)
	 - loop over the timesteps and plots them

2.2 Copy & Delete
=================

A copy-feature can also be implemented as some extension method
to ISessionInfo, IGridInfo, IProjectInfo, ...

A delete-feature is a bit special: since there is no way to explicitly 'delete' objects in memory, 
we suggest a 'IDisposable' - design pattern: Calling Dispose() on some IDatabaseInfo - object
at first initiates the deletion of files and puts the IDatabaseInfo into a disposed state.
However, some "Do you really want to ..." -- feature should be implemented to prevent 
accidential loss of data.


3. the API, further details
===========================

3.1 Chains of sessions
----------------------

Very often, a specific calculation may consist of more than one session.
One reason for this may be, that some clusters kill jobs after 24 hours, and so 
calculations must be restarted. For handling such interrupted runs, it would be 
convenient to group the sessions into 'chains'.

   // "chains" are, like projects, "implicit objects", i.e.
   // they have no real counterpart on the harddisk, like e.g. a session;
   // instead, the are constructed from all the sessions in some project,
   // by 'chaining' the sessions together according to their <see ISessionInfo.RestartedFrom>
   // properties.
   IChainInfo : IDatabaseInfoObject {
       IEnumerable<ISessionInfo> Session;
	   
	   // the timesteps of a chain are the union of all timesteps in all sessions of the chain
	   // Functions like 'Plot(...)' can now be executed on chains;
	   IEnumerable<ITimestepInfo> Timesteps;
   }

A similar concept could be used for grouping all sessions which belong to a specific parameter study.


4. Implementation
=================

Speedup of loading-time: 
the current DBE is quite slow on loading large databases. This is mainl because a high number
of various 'info-files', which more ore less represent the objects mentioned above, 
have to be openend and loaded. However, since most (all ?) of them are immuteable, 
it seems possible to cache the IDatabaseInfo-objects in some index-file, that could e.g.
be stored in the root directory of the database.
On startup, all info-objects may be loaded from index file, while some background thread 
updates the index. Since the Sessions are immuteable, the background thread could obtain
a list of session Guids by directory listing (which should be reasonable fast on any decent system),
and compare those to the ISessionInfo-objects in its index. By doing so, only the differences
need to be loaded from disk.





