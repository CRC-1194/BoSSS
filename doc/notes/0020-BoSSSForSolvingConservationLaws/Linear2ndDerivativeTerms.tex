\documentclass[BoSSSForSolvingConservationLaws.tex]{subfiles}
\raggedbottom
\begin{document}

Suppose that in the scalar conservation law equation \eqref{ScalarConservationLaw} flux depends also (linearly) on gradient of the dependent variable, $\vec{f}=f(u,\nabla u,\vec{x},t)$. Then we have moreover a term such as the following to discretize. $g$ is a linear function of $u$ and $\nu(\vec{x})$ is a parameter.
\begin{equation}
\nabla \cdot (\nu(\vec{x}) \nabla g(u))
\end{equation}
We use the common framework for DG discretization of $2$nd order derivative terms \cite{arnoldunified2002}. First we rewrite the equation into a set of first order derivative terms by introducing a new variable $\grvec{\sigma}$.
\begin{subequations}
\begin{align}
\label{DerivativeVariable}
&\grvec{\sigma}=\nu \nabla g(u)\\
&\nabla \cdot \grvec{\sigma}
\end{align}
\end{subequations}
Then we multiply relation \eqref{DerivativeVariable} by test function $\grvec{\tau}$ and the term $\nabla \cdot \grvec{\sigma}$ by test function $\phi$ and integrate over a cell $K$.
\begin{subequations}
\begin{align}
&\int_K \grvec{\sigma} \cdot \grvec{\tau} d\vec{x}=\int_K \nu \nabla g(u) \cdot \grvec{\tau} d\vec{x}\\
&\int_K \nabla \cdot \grvec{\sigma} \phi d\vec{x}
\end{align}
\end{subequations}
Integrating by parts and substituting numerical fluxes we arrive at
\begin{subequations}
\begin{align}
\label{DerivativeVariable-Discrete}
&\int_K \grvec{\sigma}^h \cdot \grvec{\tau} d\vec{x}
%=-\int_K g(u) \nabla \cdot (\nu \grvec{\tau}) d\vec{x}+ \int_{\partial_K} g(u) \hat{n}\cdot(\nu \grvec{\tau}) d\vec{x}
=-\int_K g(u^h) \nabla \cdot (\nu^h \grvec{\tau}) d\vec{x}+ \int_{\partial_K} g^*(u^h) \hat{n}\cdot(\nu^h \grvec{\tau}) d\vec{x}\\
\label{Substitute}
&\int_K \nabla \cdot \grvec{\sigma}^h \phi d\vec{x}
%=-\int_K \grvec{\sigma} \cdot \nabla \phi d\vec{x}+\int_{\partial_K} \hat{n} \cdot \grvec{\sigma} \phi d\vec{x}
=-\int_K \grvec{\sigma}^h \cdot \nabla \phi d\vec{x}+\int_{\partial_K} \hat{n} \cdot \grvec{\sigma}^* \phi d\vec{x}
\end{align}
\end{subequations}
If we choose $\grvec{\tau}=\nabla \phi$ we can substitute $\int_K \grvec{\sigma}^h \cdot \nabla \phi d\vec{x}$ from the first relation into the second one but before that we use integration by parts once again in the first equation, not to encounter to the second derivatives of the test function $\phi$. So from \eqref{DerivativeVariable-Discrete}
\begin{align*}
\int_K \grvec{\sigma}^h \cdot \nabla \phi d\vec{x}&=\int_K \nabla g(u^h) \nu^h \cdot \nabla \phi d\vec{x}-\int_{\partial_K} g(u^h) \hat{n}\cdot (\nu^h \nabla \phi) d\vec{x}+\int_{\partial_K} g^*(u^h) \hat{n}\cdot (\nu^h \nabla\phi) d\vec{x}\\
&=\int_K \nabla g(u^h) \nu^h \cdot \nabla \phi d\vec{x}+\int_{\partial_K} (g^*(u^h) -g(u^h)) \hat{n}\cdot(\nu^h \nabla\phi) d\vec{x}
\end{align*}
Now by substituting the above relation into relation \eqref{Substitute} we have the final discretized form for our second order derivative term for cell $j$.
\begin{align}
\label{DiscretizedLinear2ndDerivativeTerm}
\int_{K_j} \nabla \cdot \grvec{\sigma}_j^h \phi_{jm} d\vec{x}=&-\int_{K_j} \nabla g(u_j^h) \nu_j^h \cdot \nabla \phi_{jm} d\vec{x}\\
&+\int_{\partial_{K_j}} \hat{n} \cdot \grvec{\sigma}_j^* \phi_{jm} d\vec{x}-\int_{\partial_{K_j}} (g^*(u_j^h) -g(u_j^h)) \nu_j^h \hat{n}\cdot \nabla\phi_{jm} d\vec{x}, \qquad 0\leq m \leq N_p-1 \nonumber
\end{align}
Choice of numerical fluxes for $\grvec{\sigma}^*=\grvec{\sigma}^*(u,\nabla u,\hat{n})$ and $u^*=u^*(u,\hat{n})$ is different for different DG schemes. For example for the Interior Penalty method (IP)
\begin{align*}
&u^*=\{u\}\\
&\grvec{\sigma}^*=\nu \big(\{\nabla u\}-\alpha_i [[u]]\big)
\end{align*}
$\{.\}$ and $[[.]]$ are average and jump operators defined as
\begin{align*}
&\{u\}=\frac{1}{2}(u^+ + u^-)\\
&[[u]]=u^+ \hat{n}^+ + u^- \hat{n}^-=(u^- - u^+)\hat{n}
\end{align*}
$\alpha$ is penalty parameter which is necessary for stabilization. It is a positive constant. It is edge dependent for IP method \cite{shahbaziexplicit2005}.

\subsection*{BoSSS implementation}
First of all
$u$ is called \emph{primal variable}, $\grvec{\sigma}$ \emph{derivative variable} and $g(u)$ \emph{flux potential}\coderm{BoSSS.Foundation.ILinear2ndDerivativeFlux.FluxPotential(...)}. Numerical flux of the primal variable $g^*(u^h)$ is found from primal variable inner edge\coderm{BoSSS.Foundation.ILinear2ndDerivativeFlux.PrimalVar\_InnerEdgeFlux(...)} and border edge\coderm{BoSSS.Foundation.ILinear2ndDerivativeFlux.PrimalVar\_BorderEdgeFlux(...)} fluxes. Also Numerical flux of the derivative variable $\grvec{\sigma}^* \cdot \hat{n}$ is found from derivative variable inner edge\coderm{BoSSS.Foundation.ILinear2ndDerivativeFlux.DerivativVar\_InnerEdgeFlux(...)} and border edge\coderm{BoSSS.Foundation.ILinear2ndDerivativeFlux.DerivativVar\_BorderEdgeFlux(...)} fluxes. To use $2$nd order derivative terms we should derive our flux from $Linear2ndDerivativeFlux$\coderm{BoSSS.BoSSS.Solution.Utils.Linear2ndDerivativeFlux} and add it to our spatial differential operator.\\
The first term in equation \eqref{DiscretizedLinear2ndDerivativeTerm} corresponds to linear volume quadrature and the other terms are related to linear edge quadrature (see section \ref{sec:LECQuadrature}, \nameref{sec:LECQuadrature}).
All what we need to do, is to compute the integrands and add them to the evaluation result of the linear quadrature.\\

\subsubsection*{In volume quadrature}
With respect to \nameref{sec:LinearVolumeQuadrature} in section \ref{sec:LinearVolumeQuadrature}, the first following line is added to the sum we had before
\begin{align*}
&sum+=m\_GradientBasisFunctions[\gamma][n\_Node, n, d] \times RR\_x\_grTstFunc[d]\\
&EvalResult[j, n\_node, m\_MyOwnMapping.m\_Mapping[\gamma, m, \delta, n]=sum
\end{align*}
In above, multiplying by gradient of basis polynomials accounts for gradient of flux potential in the integrand. Therefore values of gradients of basis polynomials are also found besides the basis polynomials, test functions and gradient of test functions. The term $RR\_x\_grTstFunc[d]$ used in calculation of integrand is calculated as follows
\begin{align*}
&RR\_x\_grTstFunc[d]=\_RR\_x\_grTstFunc[d]\times \_2ndDerivFlxTot[\delta]\\
&\_RR\_x\_grTstFunc[d]=RR[d,d] \times m\_GradientTestFunctions[\gamma][n\_Node, m, d]\\
\end{align*}
$RR=((M_j)^{-1})^T((M_j)^{-1}) \times \frac{1}{|det(M_j)|}$ accounts for transformation of the integrand to physical domain. Gradient of test function is multiplied like in case of every other volume integral. The flux potential $\_2ndDerivFlxTot[\delta]$ is found when summing up fluxes\coderm{BoSSS.Foundation.Quadrature.Linear.LECVolumeQuadrature.SumUp2ndDerivativeFluxComponents(...)} for codomain variable $\gamma$. It also includes the parameter $\nu_j^h$. For flux potential no affine offset is considered because any way its gradient would be zero.\\

\subsubsection*{In edge quadrature}
Numerical fluxes are considered in the following matrix form.
\begin{align*}
&g^*(u^h)=g(u^*)=A_{PV} u_j^h + A_{PV}' u_{j'}^h+B_{PV}\\
&\hat{n} \cdot \grvec{\sigma}^*(u^h,\nabla u^h,\hat{n})=A_{DV\_PV}u_j^h+A_{DV\_DV}\hat{n} \cdot \nabla u_j^h+A_{DV\_PV}' u_{j'}^h+A_{DV\_DV}' \hat{n} \cdot \nabla u_{j'}^h+B_{DV}
\end{align*}
$B_{PV}$ and $B_{DV}$ are affine offsets for primal and derivative variables. This formulation is considered for both inner edge and boundary edge fluxes but there is no contribution from boundary edge fluxes to matrices corresponding to neighbor cell j'.\\
For each codomain variable $\gamma$ these matrices are found\coderm{BoSSS.Foundation.Quadrature.Linear.LECQuadratureEdge.Eval2ndDerivFluxes(...)} as $\_2ndDrv\_PVF\_mtx\_in[\delta]$,\\ $\_2ndDrv\_PVF\_mtx\_out[\delta]$ and $\_2ndDrv\_PVF\_affine$ for the primal variable and\\
$\_2ndDrv\_DVF\_PV\_mtx\_in[\delta]$, $\_2ndDrv\_DVF\_DV\_mtx\_in[\delta]$, $\_2ndDrv\_DVF\_PV\_mtx\_out[\delta]$, $\_2ndDrv\_DVF\_DV\_mtx\_out[\delta]$ and $\_2ndDrv\_DVF\_affine$ for the derivative variable.\\

\subsubsection*{\emph{Evaluating the integrands}}
Evaluating integrand of integral $\int_{E_i} \hat{n} \cdot \grvec{\sigma}_j^* \phi_{jm} d\vec{x}$ for edge $i$ is straight forward. It looks the same as what we had before as integrand in \nameref{sec:LinearEdgeQuadrature} of section \ref{sec:LinearEdgeQuadrature}. So it is accumulated to that
\begin{align*}
&sIn+=\_2ndDrv\_DVF\_PV\_mtx\_in[\delta] \times m\_BasisFunctions\_1stCell[e, \gamma][\delta][n\_node,n] \times scale0\\
&sIn+= \_2ndDrv\_DVF\_DV\_mtx\_in[\delta] \times \_gradBasisFunc0Xnormal[\gamma,\delta][n\_Node, n]
\end{align*}
$\_gradBasisFunc0Xnormal$ is gradient of basis polynomials of the first neighbor multiplied by the normal vector. This accounts for the gradient of primal variable in the numerical flux. Transformation to physical domain for gradient operator is also included. The same procedure holds for the second neighbor
\begin{align*}
&sOut+=\_2ndDrv\_DVF\_PV\_mtx\_out[\delta] \times m\_BasisFunctions\_2ndCell[e, \gamma, k][\delta][n\_node,n] \times scale1\\
&sOut+=\_2ndDrv\_DVF\_DV\_mtx\_out[\delta] \times \_gradBasisFunc1Xnormal[\gamma,\delta][n\_Node, n]
\end{align*}
For evaluating integrand of the integral $-\int_{E_i} (g^*(u_j^h) -g(u_j^h)) \nu_j^h \hat{n}\cdot \nabla\phi_{jm} d\vec{x}$ first we need to multiply gradient of test functions with the normal vector and transform it to physical domain\coderm{BoSSS.Foundation.Quadrature.Linear.LECQuadratureEdge.TransformTestFuncGradient(...)}.
\begin{align*}
\_gradTestFuncXnormalIn[\gamma][n\_node,m]=&Normal[dd] \times Rin[dd, d] \times scale0 \\
&\times m\_GradTestFunctions\_1stCell[e, \gamma][n\_node, m, d]\\
\_gradTestFuncXnormalOut[\gamma][n\_node,m]=&Normal[dd] \times Rout[dd, d] \times scale1 \\
&\times m\_GradTestFunctions\_2ndCell[e, \gamma, k][n\_node, m, d]
\end{align*}
Then we subtract the flux potential from the numerical one, $g^*(u_j^h)-g(u_j^h)=(A_{PV}-A_{FP}) u_j^h + A_{PV}' u_{j'}^h+B_{PV}$ and multiply by parameter $v_j^h$. Minus sign of the integral must be considered here. For the first neighbor,
\begin{align*}
tInRow\_InCol -=&\nu \times (\_2ndDrv\_PVF\_mtx\_in[\delta] - \_2ndDrv\_PotF\_mtx[\delta]) \\
&\times m\_BasisFunctions\_1stCell[e, \gamma][\delta][n\_Node, n] \times scale0\\
tInRow\_OutCol -=& \nu \times \_2ndDrv\_PVF\_mtx\_out[\delta] \\
&\times m\_BasisFunctions\_2ndCell[e, \gamma, k][\delta][n\_Node, n] \times scale1
\end{align*}
for the second neighbor
\begin{align*}
tOutRow\_InCol -=& \nu \times \_2ndDrv\_PVF\_mtx\_in[\delta] \\
&\times m\_BasisFunctions\_1stCell[e, \gamma][\delta][n\_Node, n] \times scale0\\
tOutRow\_OutCol -=& \nu \times (\_2ndDrv\_PVF\_mtx\_out[\delta] - \_2ndDrv\_PotF\_mtx[\delta])\\
&\times m\_BasisFunctions\_2ndCell[e, \gamma, k][\delta][n\_Node, n] \times scale1
\end{align*}
Multiplying by the calculated ''gradient of test function multiplied by normal vector'',\\
for the first neighbor
\begin{align*}
&tInRow\_InCol\_X\_tst = tInRow\_InCol \times \_gradTestFuncXnormalIn[\gamma][n\_node,m]\\
&tInRow\_OutCol\_X\_tst = tInRow\_OutCol \times \_gradTestFuncXnormalIn[\gamma][n\_node,m]
\end{align*}
and for the second neighbor
\begin{align*}
&tOutRow\_InCol\_X\_tst = tOutRow\_InCol \times \_gradTestFuncXnormalOut[\gamma][n\_node,m]\\
&tOutRow\_OutCol\_X\_tst = tOutRow\_OutCol \times \_gradTestFuncXnormalOut[\gamma][n\_node,m]
\end{align*}
Summing up the integrands is modified to consider $2$nd order derivative terms.\\
For the first neighbor
\begin{align*}
EvalResult&[i, n\_Node, m\_iIn\_In_ + m\_MyOwnMapping.m\_Mapping[\gamma, m, \delta, n]] = \\&sIn \times scale0 \times m\_TestFunctions\_1stCell[e, \gamma][n\_node,m] + tInRow\_InCol\_X\_tst\\
EvalResult&[i, n\_Node, m\_iIn\_Out + m\_MyOwnMapping.m\_Mapping[\gamma, m, \delta, n]] = \\&sOut \times scale0 \times m\_TestFunctions\_1stCell[e, \gamma][n\_node,m] + tInRow\_OutCol\_X\_tst
\end{align*}
and for the second neighbor
\begin{align*}
EvalResult&[i, n\_Node, m\_iOutIn\_ + m\_MyOwnMapping.m\_Mapping[\gamma, m, \delta, n]] = \\&sIn \times scale1 \times m\_TestFunctions\_2ndCell[e, \gamma, k][n\_node,m]\\
EvalResult&[i, n\_Node, m\_iOutOut + \_MyOwnMapping.m\_Mapping[\gamma, m, \delta, n]] = \\&sOut \times scale1 \times m\_TestFunctions\_2ndCell[e, \gamma, k][n\_node,m] + tOutRow\_OutCol\_X\_tst\\
\end{align*}
Also summing up the affine offsets is modified to consider $2$nd order derivative terms.\\
For the first neighbor we have
\begin{align*}
EvalResult&[i, n\_Node, m\_iIn\_Out + m\_MyOwnMapping.m\_MappingOffset[\gamma, m]] =\\
&FlxTotalOffset \times m\_TestFunctions\_1stCell[e, \gamma][n\_node,m] \times scale0\\
&+ \_2ndDrv\_DVF\_affine \times m\_TestFunctions\_1stCell[e, \gamma][n\_node,m] \times scale0\\
&- \_2ndDrv\_PVF\_affine \times \nu \times \_gradTestFuncXnormalIn[\gamma][n\_node,m]\\
&+tOutRow\_InCol\_X\_tst
\end{align*}
and for the second neighbor
\begin{align*}
EvalResult&[i, n\_Node, m\_iOutOut + m\_MyOwnMapping.m\_MappingOffset[\gamma, m]] =\\
&FlxTotalOffset \times m\_TestFunctions\_2ndCell[e, \gamma, k][n\_node,m] \times scale1 \\
&+ \_2ndDrv\_DVF\_affine \times m\_TestFunctions\_2ndCell[e, \gamma, k][n\_node,m] \times scale1\\
&- \_2ndDrv\_PVF\_affine \times \nu \times \_gradTestFuncXnormalOut[\gamma][n\_node,m]
\end{align*}
\end{document} 