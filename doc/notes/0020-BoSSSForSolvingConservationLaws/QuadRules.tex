\documentclass[BoSSSForSolvingConservationLaws.tex]{subfiles}

\begin{document}
A \emph{quadrature rule} is an approximation of a definite integral of a function $f(\vec{x})$. It is stated as a weighted sum of function values at specified points within domain of integration. For example for integration in $1D$ an $N$-point Gaussian quadrature rule yields exact results for integration of polynomials of degree $2N-1$ or less by a suitable choice of points and weights. Exactness of the computed integral follows from exactness of integration of polynomials of degree $N$.
\[
\int_K f(\vec{x}) d(\vec{x})\approx \sum_{l=1}^N w_l f(\vec{x}_l)
\]
Gaussian quadrature as defined above will only produce accurate results if function $f(\vec{x})$ is well approximated by a polynomial function within domain $K$. The method is not for example suitable for functions with singularities.

\begin{comment}
The domain of integration for such a rule in 1D is conventionally taken as [-1, 1].
However, if the integrand is $w(x)f(x)$ which $f(x)$ is a polynomial of order $2n-1$ and $p_n(x)$ is a class of orthogonal polynomials with respect to $w(x)$, then the evaluation points $x_i$ are roots of $p_n(x)$ in the interval $(-1,1)$ and the weights $w_i$ are $w(x_i)$.
\begin{align}
\int_{-1}^1 w(x)f(x)d(x)=\int_{-1}^1 w(x)[q(x)p_n(x)+r(x)]dx=\int_{-1}^1 w(x)r(x)d(x)\simeq \sum_{i=1}^n w_i r(x_i)
\end{align}
Therefore the exactness of the computed integral for $f(x)$ follows from corresponding exactness for polynomials of degree $n$ or less (as for $r(x)$).\\
\end{comment}

\subsection*{Implementation in BoSSS}
A quadrature rule\coderm{BoSSS.Foundation.Quadrature.QuadRule} contains \emph{Nodes}\coderm{BoSSS.Foundation.Quadrature.QuadRule.Nodes} and \emph{weights}\coderm{BoSSS.Foundation.Quadrature.QuadRule.Weights} for a required \emph{order of precision}\coderm{BoSSS.Foundation.Quadrature.QuadRule.OrderOfPrecision}. Nodes, is a 2D array of doubles which stores the spatial coordinates of the quadrature points in the reference domain (\emph{simplex}). A collection\coderm{BoSSS.Foundation.Grid.Simplex.m\_QuadRules} of these quadrature rules is available for each simplex and based on the desired precision one can choose\coderm{BoSSS.Foundation.Grid.Simplex.GetQuadratureRule(...)} the appropriate quadrature rule. According to \emph{quadrature type}\coderm{BoSSS.Foundation.Quadrature.Quadrature.QuadType} (Volume, Edge or ...) the quadrature rule\coderm{BoSSS.Foundation.Quadrature.Quadrature.\_QuadRule} is defined\coderm{BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon.NECQuadratureCommon(...)} for volume simplex\coderm{BoSSS.Foundation.Grid.GridCommons.GridSimplex} or edge simplex\coderm{BoSSS.Foundation.Grid.Simplex.EdgeSimplex}.\\

\subsubsection*{Execution of quadrature}
Consider we want to integrate\coderm{BoSSS.Foundation.Quadrature.Quadrature.Execute(...)} several integrals on some \emph{quadrature items} (cells or edges). Maximum number of items $MaxTotalNumberOfItems$ is considered as \emph{number of locally updated cells} \coderm{BoSSS.Foundation.Grid.GridData.NoOfLocalUpdatedCells} if the quadrature type is Volume or number of edges on a processor if the quadrature type is Edge. The integration process is called \emph{execution of quadrature}. The quadrature is executed on a quadrature execution mask\coderm{BoSSS.Foundation.Quadrature.ExecutionMask}. The purpose of the execution mask is to restrict the execution of a quadrature to some sub-domain. Per default (without specifying an execution mask) it is executed over all cells or edges. Type of the execution mask\coderm{BoSSS.Foundation.Quadrature.ExecutionMask.Qtype} must be the same as the quadrature type. Quadrature execution process has the following steps.
\begin{enumerate}
\item \textbf{Creating node set family}\\
We take\coderm{BoSSS.Foundation.Quadrature.Quadrature.InitNodeSetFamiliy(...)} nodes of the quadrature rule and create\coderm{BoSSS.Foundation.Quadrature.Quadrature.CreateNodeSetFamily(...)} a \emph{node set family}\coderm{BoSSS.Foundation.Quadrature.Quadrature.m\_NodeSetFamily} out of them. Nodes of each node set in a node set family are stored in the coordinate system of the volume simplex and they are called \emph{untransformed nodes} (this is also the case when the quadrature type is Edge).
\item \textbf{Specifying memory}\\
Memory is specified\coderm{BoSSS.Foundation.Quadrature.quadrature.AllocateBuffers(...)} for arrays which are needed to store the integrands and the integration results.
\item \textbf{Evaluation of integrands}\\
Evaluation\coderm{BoSSS.Foundation.Quadrature.Quadrature.Evaluate(...)} of the integrands at the quadrature points would be different for different types of integrands however the \emph{evaluation results}\coderm{BoSSS.Foundation.Quadrature.Quadrature.m\_EvalResults} is a $3D$ array stored for each quadrature item at each node and for each integral.
\item \textbf{Integration}\\
Evaluated integrands are multiplied by the corresponding weights and summed up over all quadrature points at all quadrature items. Then they are scaled because the integration is performed in a reference domain (see \ref{sec:Element-wise operations}, \nameref{sec:Element-wise operations}). Results of integration or \emph{quadrature results}\coderm{BoSSS.Foundation.Quadrature.Quadrature.m\_QuadResults} are stored in a $2D$ array for each quadrature item and each integral.
\item \textbf{Saving integration results}\\
Integration results can be saved\coderm{BoSSS.Foundation.Quadrature.Quadrature.SaveIntegrationResults(...)} differently to be used for specific purposes.
\end{enumerate}

Details of the steps above is of course different for volume and edge integrals and also for linear or nonlinear integrands. For the details see sections \ref{sec:NECQuadrature} and \ref{sec:LECQuadrature}.

\end{document} 