\documentclass[emamy.tex]{subfiles}

\begin{document}
A \emph{spatial differential operator} (see more at \cite{KummerLayer2Manual09}) handles spatial discretization of an equation or a system of equations which are solved simultaneously. A spatial differential operator has some \emph{domain}, \emph{codomain} and \emph{parameter} variables. Domain variables are in fact unknowns of the equations. $U$ is matrix and $\Lambda$ is number of domain variables.
\[
U=\begin{bmatrix}
    u_0\\
    \vdots\\
    u_{\Lambda-1}
  \end{bmatrix}
\]
\nomenclature{U}{Matrix of domain variables}
\nomenclature{$\Lambda$}{Number of domain variables}
Codomain variables have the form
\[
w_{\gamma}=div(\vec{f}_{\gamma}(U,\vec{x}))+q_{\gamma}(U,\vec{x}), \qquad 0\leq \gamma \leq \Gamma-1
\]
\nomenclature{$\Gamma$}{Number of the codomain variables}
\nomenclature{$\gamma$}{Index for codomain variables}
Number of codomain variables, $\Gamma$, is the same as number of equations. In general $\Lambda$ and $\Gamma$ can be  chosen independently for a spatial differential operator but if we are going to solve a system of equations with it, they must be the same to have the same number of unknowns and equations. For each codomain variable there are some corresponding \emph{equation component}s. An equation component maps from domain variables to one codomain variable (and in fact is a spatial differential operator itself). Equation components are either fluxes or sources which can be linear or nonlinear. Equation components with the same type are additive. If beside the domain variables some more variables are needed for calculation of codomain variables, they are considered as parameters.\\ Referring to spatial discretization of a scalar conservation law, equation \eqref{WeakFormulation-BoSSSStyle}, there are $N_p$ equations to be solved involving computation of following integrals on elements and edges of domain.
\begin{align}
\label{QuadratureVolumeIntegral}
-\int_{K_j} [\vec{f}_j^h\cdot \nabla \phi_{jm} - q_j^h \phi_{jm}] d\vec{x}, &\qquad 0\leq m \leq N_p-1\\
\label{QuadratureEdgeIntegral}
\int_{E_i} \hat{n}\cdot \vec{f}_j^* \phi_{jm} d\vec{x}, \quad E_i \in \partial K_j, &\qquad 0\leq m \leq N_p-1
\end{align}
\nomenclature{$E_i$}{Edge i}
This is called \emph{evaluating} the spatial differential operator.\\
In case of more than one equation, each codomain variable $w_\gamma$ may have a different basis of orthonormal polynomials therefore \emph{number of discretized equations} to be solved is $\sum_{\gamma=0}^{\Gamma-1} N_{p \gamma}$ in each cell.

\subsection*{Implementation in BoSSS}
When a spatial differential operator is created, first lists of domain\coderm{BoSSS.Foundation.SpatialDifferentialOperator.DomainVar}, parameters\coderm{BoSSS.Foundation.SpatialDifferentialOperator.ParameterVar} and codomain variables\coderm{BoSSS.Foundation.SpatialDifferentialOperator.CodomainVar} are created which are string arrays of their names. Then a sorted list is created to store equation components\coderm{BoSSS.Foundation.SpatialDifferentialOperator.EquationComponents} of the spatial differential operator . In this sorted list for each codomain variable a list of equation components\coderm{BoSSS.Foundation.IEquationComponent} exists. To see details of the steps above see constructor of class \emph{SpatialDifferentialOperator}\coderm{BoSSS.Foundation.SpatialDifferentialOperator}.\\
Before using a spatial differential operator we need to \emph{add} equation components (fluxes and sources) for all codomain variables and commit\coderm{BoSSS.Foundation.SpatialDifferentialOperator.Commit()} the spatial differential operator. Committing is necessary because it checks\coderm{BoSSS.Foundation.SpatialDifferentialOperator.verify()} that all \emph{arguments}, \emph{parameters} and \emph{output} variables used by fluxes and sources, exist in the defined domain, parameters and codomain variables of the spatial differential operator.

\subsubsection*{Evaluating a spatial differential operator}
Evaluating\coderm{BoSSS.Foundation.SpatialDifferentialOperator.Evaluator.Evaluate(...)} a spatial differential operator means calculating integrals shown in equation \ref{QuadratureVolumeIntegral} and \ref{QuadratureEdgeIntegral} of all codomain variables for the whole domain or a part of it (using \emph{execution mask}). Although the integration procedure is different for linear and nonlinear equation components and for volume and edge integrals, results are accumulated at \emph{output} which is a $1D$ array of doubles. Index to this array is found by \emph{coordinate mapping} of the codomain variables (see section \ref{sec:CoordinateMapping}, \nameref{sec:CoordinateMapping}).\\
Before we can evaluate a spatial differential operator we must create\coderm{BoSSS.Foundation.SpatialDifferentialOperator.GetEvaluatorEx()} an \emph{evaluator}\coderm{BoSSS.Foundation.SpatialDifferentialOperator.Evaluator} for it. An evaluator is created by knowing coordinate mappings of domain, parameter and codomain variables. The evaluator creates\coderm{BoSSS.Foundation.SpatialDifferentialOperator.Evaluator.Evaluator(...)} and computes\coderm{BoSSS.Foundation.SpatialDifferentialOperator.ComputeMatrixEx(...)} $Matrix$ and $m\_AffineOffset$\coderm{BoSSS.Foundation.SpatialDifferentialOperator.Evaluator.m\_AffineOffset} if the operator contains\coderm{BoSSS.Foundation.SpatialDifferentialOperator.ContainsLinear(...)} linear parts and creates\coderm{BoSSS.Foundation.SpatialDifferentialOperator.GetNonlinQuadrature(...)} \emph{nonlinear quadratures} if the operator contains\coderm{BoSSS.Foundation.SpatialDifferentialOperator.ContainsNonlinear(...)} nonlinear parts. Nonlinear quadrature consists of \emph{nonlinear volume quadrature}\coderm{BoSSS.Foundation.Quadrature.NonLin.NECQuadratureVolume} and \emph{nonlinear edge quadrature}\coderm{BoSSS.Foundation.Quadrature.NonLin.NECQuadratureEdge}. To know about these nonlinear equation components'\coderm{BoSSS.Foundation.Quadrature.NonLin.NECQuadratureCommon} quadrature see section \ref{sec:NECQuadrature}, \nameref{sec:NECQuadrature}. Linear quadrature is explained at section \ref{sec:LECQuadrature}, \nameref{sec:LECQuadrature}.\\
By evaluating a spatial differential operator, nonlinear quadratures are executed\coderm{BoSSS.Foundation.Quadrature.Quadrature.Execute(...)} (see section \ref{sec:QuadRules}, \nameref{sec:QuadRules}) and the matrix ($m\_Matrix$)\coderm{BoSSS.Foundation.SpatialDifferentialOperator.Evaluator.m\_Matrix} of the linear quadrature is multiplied\coderm{ilPSP.LinSolvers.ISparseMatrix.SpMV} by DG coordinates of domain variables and added up with the affine offset ($m\_AffineOffset$). Results are accumulated to provide the output of the spatial differential operator. $Matrix$ is an MsrMatrix which its rows are distributed among processors. $m\_Matrix$ is a RefMatrix made from $Matrix$ by distributing also its columns among processors. For more information see \nameref{sec:MsrMatrix} in section \ref{sec:MsrMatrix}.\\
If you want to limit evaluation of a spatial differential operator to a sub-domain, you should define the desired sub-domain as an execution mask, because in general quadratures are executed on execution masks. Some examples of available execution masks are boundary cells\coderm{BoSSS.Foundation.Grid.GridData.BoundaryCells}, Internal cells\coderm{BoSSS.Foundation.Grid.GridData.InternalCells} and Boundary edges\coderm{BoSSS.Foundation.Grid.GridData.BoundaryEdges}.

\end{document} 