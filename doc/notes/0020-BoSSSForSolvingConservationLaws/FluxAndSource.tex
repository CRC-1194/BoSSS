\documentclass[BoSSSForSolvingConservationLaws.tex]{subfiles}

\begin{document}
\subsection{Physical and numerical flux functions}
Referring to the weak formulation of a scalar conservation law equation \eqref{WeakFormulation-BoSSSStyle}, $\vec{f}$ and $\vec{f}^*$ are the physical and numerical flux functions which both depend on the variable $u(\vec{x},t)$, spatial coordinates $\vec{x}$ and time $t$. Choice of the numerical flux (function) $f^*(u_{-}^h,u_{+}^h)$ is very important. First of all it should be consistent $f^*(u^h,u^h)=f(u^h)$. Another guideline is to require that the chosen flux reduces to a monotone scheme in the low order/finite volume limit. This is insured by requiring that $f^*(a,b)$ is nondecreasing in first argument and nonincreasing in second one. Another definition of a monotone flux is as an E-flux, satisfying\\
\[
\forall v \exists [a,b]: (f^*(a,b)-f(v))(b-a) \leq 0, \qquad a<v<b
\]
There are a lot of fluxes with the above property defined in the classic finite volume literature.\\
\begin{comment}
The Lax-Friedrichs flux is perhaps the simplest numerical flux and often the most efficient flux, but generally not leading to the most accurate scheme. Clearly, it contains as special cases the central flux and the upwind flux for scalar linear problems.
\[
f^{LF}(a,b)=\frac{a+b}{2}+\frac{C}{2} \hat{n}.(a-b)
\]
\end{comment}
Fluxes can be linear or nonlinear functions with respect to variable $u$. This leads to different discretizations of the equation. Nonlinear fluxes should be first linearized so that they can be handled with explicit time discretization. This means that values of variable $u$ from initial or previous time steps are used for calculating the flux. If there are some parameters needed for calculation of the flux they can be included in in arguments. When the flux function is linear it can be handled with explicit or implicit time discretizations. If an implicit scheme is chosen we arrive at a matrix formulation. In this case parameters must be provided if they are needed.

\subsection*{Implementation in BoSSS}
In case of both nonlinear and linear fluxes there are methods $Flux$ for physical flux $\vec{f}$ and $InnerEdgeFlux$ and $BorderEdgeFlux$ for numerical flux $\vec{f}^*.\hat{n}$. All these methods have two versions, one used by quadratures and the other implemented by user and added as equation component to the spatial differential operator.\\
\subsubsection{Nonlinear flux}
$NonlinearFlux$\coderm{BoSSS.Solution.Utils.NonlinearFlux} is used for nonlinear physical and numerical flux functions. $Flux$\coderm{BoSSS.Solution.Utils.NonlinearFlux.Flux(...)} which calculates the Physical flux function $\vec{f}(U,\vec{x},t)$ must be provided by $time$, array of spatial coordinates of desired nodes $x[j,n\_node,d]$ and array of arguments $U[l][j,n\_node]$ for all cells. $l$\nomenclature{$l$}{Index for flux or source arguments} is index for arguments. For each cell $j$ and node $n\_node$ the user defined version of $Flux$ is used to calculate $m\_Flux[d]$, the flux at that node. This version of $Flux$ is provided by the required data at a node which are $time$, $m\_x[d]$ and $m\_Uin[l]$. The calculated flux is accumulated at $Output[j,n\_node,d]$. This output is used as $m\_FluxValues[\gamma][j,n\_node,d]$ in the nonlinear volume quadrature.\\
$InnerEdgeFlux$\coderm{BoSSS.Solution.Utils.NonlinearFlux.InnerEdgeFlux(...)} must be provided by $time$, spatial coordinates $x[i,n\_node,d]$, normal vectors\coderm{BoSSS.Foundation.Grid.GridData.Normals} $normal[i,d]$ and flux arguments of the first neighbors $Uin[l][i,n\_node]$ and second neighbors $Uout[l][i,n\_node]$ for all edges. For each edge $i$ and node $n\_node$, the user defined version of $InnerEdgeFlux$ is provided by the data at the node and the calculated flux is accumulated at $Output[i,n\_node]$. This output is used as $m\_FluxValues[\gamma][i,n\_node]$ in the nonlinear edge quadrature.
The same is for a $BorderEdgeFlux$\coderm{BoSSS.Solution.Utils.NonlinearFlux.BorderEdgeFlux(...)} but there is no second neighbor; Moreover \emph{edge tags}\coderm{BoSSS.Foundation.Grid.GridData.EdgeTags} $EdgeTags[i]$ must be provided which are numbers specifying \emph{type} of boundary edges.
\subsubsection{Linear flux}
$LinearFlux$\coderm{BoSSS.Solution.Utils.LinearFlux} corresponds to matrix formulation of a linear flux and computes the associated matrices and affine offsets.
\begin{align*}
&\vec{f}(U,P,\vec{x},t)=A_F U+B_F\\
&\vec{f}^*(U_{In},U_{Out},P_{In},P_{Out},\vec{x},t).\hat{n}=A_{In} U_{In}+A_{Out} U_{Out}+B_I\\
&\vec{f}^*(U_{In},P_{In},\vec{x},t).\hat{n}=A_{In} U_{In}+B_B
\end{align*}
As we know from linear Algebra the easiest way to find the flux matrix $A_F$ and the affine matrix $B_F$ is to take the physical flux formulation and put values of arguments to zero. This would provide the affine offset and then putting the basis coordinate vectors $\vec{e}_l$ as argument and using the affine offset we find column $l$ of matrix $A_F$.
\begin{align*}
&B_F=\vec{f}(0,\vec{x},t)\\
&A_F(l)=\vec{f}(\vec{e}_l,\vec{x},t)-B_F, \qquad 0\leq l \leq N_{arg}
\end{align*}
$Flux$\coderm{BoSSS.Solution.Utils.LinearFlux.Flux(...)} method uses the user defined version of the $Flux$ and applies the above procedure to find $FunctionMatrix[d,l]$ and $AffineOffset[d]$. They are used as $FluxesComponents[\gamma][c][d,\delta]$ and $FlxCompOffset[d]$ in the linear volume quadrature. The same procedure is applied by $InnerEdgeFlux$\coderm{BoSSS.Solution.Utils.LinearFlux.InnerEdgeFlux(...)} to find $FunctionMatrixIn[l]$ and $FunctionMatrixOut[l]$ and $AffineOffset$ which is a double value. They are used as $FluxesComponentsIn[\gamma][c][\delta]$, \\$FluxesComponentsOut[\gamma][c][\delta]$ and affine offset in summing up fluxes in the linear edge quadrature. The same procedure is performed by $BorderEdgeFlux$\coderm{BoSSS.Solution.Utils.LinearFlux.BorderEdgeFlux(...)}.\\
The method $Flux$ is provided by spatial coordinates $x[d]$ and $parameters[p]$. For $InnerEdgeFlux$ and $BorderEdgeFlux$ the input data such as spatial dimension $x[d]$, $normal[d]$, $ParameterValuesIn[p]$, $ParameterValuesOut[d]$ and $EdgeTag$,...are provided by $InParams$\coderm{BoSSS.Foundation.InParams}.

\subsection{Source terms}
The source term $q(u(\vec{x},t),\vec{x},t)$ is descritized again differently based on that it is nonlinear or linear function of domain variable $u$. In nonlinear case with explicit time discretization it would be calculated using the data from initial or previous time steps but in linear case with implicit time discretization there would a matrix formulation for that.
\[
q(U,P,\vec{x},t)=A_S U+B_S
\]
\subsection*{Implementation in BoSSS}
Both $NonlinearSource$\coderm{BoSSS.Solution.Utils.NonlinearSource} and $LinearSource$\coderm{BoSSS.Solution.Utils.LinearSource} have two versions of method $Source$, one used by the quadratures and the other one implemented by user and added as equation component to a spatial differential operator. Nonlinear source\coderm{BoSSS.Solution.Utils.NonlinearSource.Source(...)} must be provided by $time$, spatial coordinates $x[j,n\_node,d]$ and array of arguments $U[l][j, n\_node]$. For each cell $j$ and node $n\_node$ the user defined version is used to calculate the source which is a double value. The calculated source is accumulated at $Output[j,n\_node]$ which is used as $m\_SourceValues[\gamma][j, n\_node]$ in the nonlinear volume quadrature.\\
Linear $Source$\coderm{BoSSS.Solution.Utils.LinearSource.Source(...)} must be provided by spatial coordinates $x[d]$ and $parameters[p]$. With the same procedure described above for linear flux, the $FunctionMatrix[l]$ and $AffineOffset$ are found. They are used as $SourceComponents[\gamma][c][\delta]$ and offset in summing up sources in linear volume quadrature.
\end{document} 